// Ming Yang

#include "board.h"
#include <iostream>
#include <cstdlib>

Board::Board() {
	spotsHit = new bool[SIZE];
	board = new int[SIZE];
	for (int i = 0; i < SIZE; i++) {
		spotsHit[i] = false;
		board[i] = -1;
	}

	targets = new Target[TARGET_COUNT];
	setupTargets();
}

Board::~Board() {
	delete [] spotsHit;
	delete [] board;
	delete [] targets;
}

Board::Board(Board& original) {
	spotsHit = new bool[SIZE];
	board = new int[SIZE];
	targets = new Target[TARGET_COUNT];

	// make deep copies of the spotsHit, board and targets
	for (int i = 0; i < SIZE; i++) {
		spotsHit[i] = original.spotsHit[i];
		board[i] = original.board[i];
	}

	for (int i = 0; i < TARGET_COUNT; i++) { 
		int size = original.targets[i].getSize();
		int location = original.targets[i].getLocation();
		targets[i].setup(size, location); 
	}
}

Board
Board::operator=(const Board& right) {
	delete [] spotsHit;
	delete [] board;
	delete [] targets;
	
	spotsHit = new bool[SIZE];
	board = new int[SIZE];
	targets = new Target[TARGET_COUNT];

	// make deep copies of the spotsHit, board and targets
	for (int i = 0; i < SIZE; i++) {
		spotsHit[i] = right.spotsHit[i];
		board[i] = right.board[i];
	}

	for (int i = 0; i < TARGET_COUNT; i++) {
		int size = right.targets[i].getSize();
		int location = right.targets[i].getLocation();	
		targets[i].setup(size, location);
	}

	return *this;
}

void
Board::hitAt(int location) {
	location -= 1;	// adjusts for client input (1-60) not
			// starting at 1	

	int targetIndex = getTargetIndex(location);
	if (targetIndex != -1)  // if a target occupies that location 
	{
		targets[targetIndex].gotHit();
		std::cout << "Result: HIT" << std::endl;
		if (targets[targetIndex].isDead())
			std::cout << "You destroyed a target!" << std::endl;
	}
	else {
		std::cout << "Result: MISS" << std::endl;
	}

	spotsHit[location] = true;
}

void
Board::displayBoard() {
	for (int location = 0; location < SIZE; location++) {
		if (isHitAlready(location)) {
		  if (getTargetIndex(location) != -1)	
			  std::cout << "x";
		  else
			  std::cout << "o";
		} else {
			std::cout << "-";
		}
	}
	std::cout << "\n\n" << std::endl;
}

bool
Board::isDefeated() {
	for (int i = 0; i < TARGET_COUNT; i++) 
		// if any aren't dead, then the player hasn't lost
		if (!(targets[i].isDead())) 
			return false;

	return true;
}

bool
Board::isHitAlready(int location) {
	// checks to see if the location has been hit
	return spotsHit[location];
}

int
Board::getLocationInput(Board board) {
	int location;
	std::cout << "Please enter the location you'd like to "
		<< "shoot (1 - 60): ";
	
	while (!(std::cin >> location)) {
		std::cout << "Not a valid location! Try again: ";
		std::cin.clear();
		std::cin.ignore(10000, '\n');
	}
	if (!Board::isLocationValid(location, board)) {
		std::cout << "Not a valid location! Try again: ";
		location = getLocationInput(board);
	}
	return location;	
}

int
Board::getLocationInput(int size) {
	int location;
	std::cout << "Please choose a location from 1 to 60 for " <<
		"your target of size " << size << ": ";
	while (!(std::cin >> location)) {
		std::cout << "Not a valid location! Try again: ";
		std::cin.clear();
		std::cin.ignore(10000, '\n');
	}
	if (!Board::isLocationValid(location, size)) {
		std::cout << "Not a valid location! Try again: ";
		location = getLocationInput(size);
	}	
	// subtract 1 to match the location input to the board array
	return location - 1;
}

bool
Board::isLocationValid(int location, int size) {
	int maxLocation = location + size - 1;
	if (location >= 1 && maxLocation <= 60) {
		for (int i = location; i <= maxLocation; i++) 
		{	// would this new target be placed on any occupied locations?
			if (board[i-1] != -1) 
				return false;
		}
		return true;
	}else {
		return false;
	}
}

// overloaded; used when getLocationInput() is called from clients
bool
Board::isLocationValid(int location, Board board) {
	if (location >= 1 && 
	    location <= 60 &&
	    !board.isHitAlready(location-1)) {
		return true;
	}else {
		return false;
	}
}

// setupTargets() -  Handles the setup of the targets - whether they are 
// user-generated or randomly generated by the program. Proceeds to call
// either selfSetupTargets() or randomSetupTargets() depending on user
// preference.
void
Board::setupTargets() {
	std::string choice;
	bool valid = false;
	std::cout << "Please enter whether you want to place the targets " <<
		"your[s]elf or have them [r]andomly placed (s or r): ";
	while (!valid) {
		std::cin >> choice;
		valid = choice == "s" || choice == "S" || 
			choice == "r" || choice == "R";
		if (!valid)
			std::cout << "Invalid entry. Please enter [s] for self or " <<
				"[r] for random: ";
	}		
	
	if (choice == "s" || choice == "S") 	selfSetupTargets();
	else 					randomSetupTargets();			}

void 
Board::selfSetupTargets() {
	int size = 2;
	for (int index = 0; index < TARGET_COUNT; index++) {	
		int location = getLocationInput(size);	
		
		targets[index].setup(size, location);
		for (int j = location; j < location + size; j++) 
		{	// board tracks which target object occupies
			// any specific spot on the board
			board[j] = index;
		}

		size++;	// increment so each target is a different size
	}
}

void
Board::randomSetupTargets() {
	int size = 2;
	for (int index = 0; index < TARGET_COUNT; index++) {
		int location = rand() % 60;
		while (!isLocationValid(location, size) || 
			isHitAlready(location)) {
			location = rand() % 60;
		}
	
		targets[index].setup(size, location);
		for (int j = location; j < location + size; j++)
		{	// board tracks which target object occupies
			// any specific spot on the board
			board[j] = index;
		}

		size++;	// increment so each target is a different size
	}
}

int
Board::getTargetIndex(int location) {
	return board[location];
}
